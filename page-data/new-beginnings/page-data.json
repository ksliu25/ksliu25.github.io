{"componentChunkName":"component---src-templates-blog-post-js","path":"/new-beginnings/","result":{"data":{"site":{"siteMetadata":{"title":"Ken's Feynman Dump"}},"markdownRemark":{"id":"9aa6f98b-05aa-57c6-93f0-6d3e44c04d02","excerpt":"Stuff taken directly from my conversations with chatgpt/Gemini because I'm too dumb to understand basic computer science Postgres MVCC lets everyone read and…","html":"<h2>Stuff taken directly from my conversations with chatgpt/Gemini because I'm too dumb to understand basic computer science</h2>\n<p>Postgres MVCC lets everyone read and write at the same time by keeping multiple versions of data. It doesn’t stop conflicts — it just avoids blocking.\nOptimistic and pessimistic locking are how the application decides what to do when conflicts matter.\nMVCC is optimistic in attitude (assume things won’t collide), but it doesn’t enforce correctness. Locking is where correctness gets enforced</p>\n<p>MVCC in Postgres is about <em>visibility</em> and ensuring that when contention does happen a version of that data is still available, albeit old. Let's consider this convoluted scenario</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Imagine a giant concert stadium.\n\nThe Snapshot (MVCC): Person A and Person B both walk up to their own separate electronic kiosks at the exact same time. When they touch the screen, the kiosk pulls a \"snapshot\" of the seating map. Both screens show one seat left (Seat 1A).\n\nThe Interpretation: * Person A thinks: \"Awesome, Seat 1A is free. I'll take it.\"\n\nPerson B thinks: \"Awesome, Seat 1A is free. I'll take it.\"\n\nThe Lost Update (The Conflict):\n\nPerson A hits \"Confirm.\" The database (Postgres) sees the seat is currently empty and marks it as \"Sold to A.\"\n\nPerson B hits \"Confirm\" a millisecond later.</code></pre></div>\n<p>In this default configuration concurrency results inw hat is called a \"lost\" update. In this case, if the seat had something like a \"sold_to\" column with an id, that could be overwritten by person B, meaning person A's update was \"lost\". Or, if it was a counter, it would be oversold.</p>\n<p>Make note that the concurrency in this case, although it says millisecond later, can specifically mean execution windows.</p>\n<p>Take a look at a default bread and butter spring boot implementaiton</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">@Transactional\npublic void purchaseTicket(Long ticketId) {\n    // 1. SELECT: Get current inventory\n    Ticket ticket = repo.findById(ticketId); // Inventory = 1\n    \n    if (ticket.getQuantity() > 0) {\n        \n        // 2. THE HUMAN WINDOW: 3rd party credit card call (takes 2 seconds)\n        paymentService.charge(user, price); \n        \n        // 3. UPDATE: Decrement and save\n        ticket.setQuantity(ticket.getQuantity() - 1);\n        repo.save(ticket); \n    }\n}</code></pre></div>\n<p>The \"Overlapping Windows\" Breakdown\nIf you have two users, Alice and Bob, the sequence looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">T1: Alice hits the endpoint. Her transaction starts. She executes SELECT and sees Quantity = 1.\n\nT2: Bob hits the endpoint. His transaction starts. He executes SELECT and also sees Quantity = 1 because Alice hasn't changed anything yet.\n\nT3: Alice is waiting for the credit card API (the 2-second \"Human Window\").\n\nT4: Bob is also waiting for the credit card API.\n\nT5: Alice’s payment clears. Her code executes the UPDATE to set Quantity = 0. Her transaction commits.\n\nT6: Bob’s payment clears. His code executes the UPDATE to set Quantity = 0. His transaction commits.\n\nThe Result: Two people paid, but the inventory only went down by 1.</code></pre></div>\n<p>What's important to note is that the actual locking mechanism is on the actual update statement, but this leaves U.S. Open for selects or reads. So when we run a select statement to read something, that's where MVC comes in. It always shows you and ensures that there's quote, unquote, clean reads. As in that you're always going to get some sort of version of it in an old snapshot in this case.</p>\n<p>And I think what's important to note is that we call this a human timing level problem because there's application business logic and there's a lower level at the databse/persistence layer.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Why this is a \"Human Level\" problem\nYou mentioned this is for human-level timing. You're right because:\n\nDB level: Transactions usually take microseconds.\n\nApp level: Between the SELECT and the UPDATE, you might have business logic, loops, or IO calls.\n\nIf you use a \"Long Conversation\" (like a user opening an 'Edit' screen, going to get coffee, and then hitting 'Save'), the window isn't 2 seconds; it's 20 minutes. Plain MVCC is completely helpless here because the database cannot hold a lock for 20 minutes while a user is away from their keyboard.</code></pre></div>\n<p>So the statement above is actually what I got from. Gemini. But I want to talk about the evolution in history of this because it helps build the intuition. A lot of these blog posts are just for me. I'm going to be the only person that reads it, but I think it's helpful for me to come back and read, hey, this is how monolithic web development applications evolve, and here's how we solve them using \"new\" techniques</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Phase 1: The \"Wild West\" (Plain MVCC)In the early days of simple web apps, we relied on the database's default behavior.The Flow: Alice reads data $\\rightarrow$ Alice sees it on her screen $\\rightarrow$ Alice clicks \"Save\" 10 minutes later $\\rightarrow$ The app sends an UPDATE.The Problem: If Bob edited the same record while Alice was at lunch, Alice’s \"Save\" would blindly overwrite Bob’s changes. This is the Lost Update in a stateless environment.Intuition: The database is just a filing cabinet. It doesn't know Alice's \"Save\" is based on 10-minute-old information.</code></pre></div>","frontmatter":{"title":"Database Fundamentals - Optimistic and Pessimistic locking","date":"January 23, 2026","description":"Reflections on optimistic and pessimistic locking specifically implemented in Spring boot with Postgres"}},"previous":null,"next":null},"pageContext":{"id":"9aa6f98b-05aa-57c6-93f0-6d3e44c04d02","previousPostId":null,"nextPostId":null}},"staticQueryHashes":["2841359383","3257411868"],"slicesMap":{}}