{"componentChunkName":"component---src-templates-blog-post-js","path":"/db-pt3/","result":{"data":{"site":{"siteMetadata":{"title":"Ken's Feynman Dump"}},"markdownRemark":{"id":"9a71fe5f-079b-54dd-af55-8b95844ba53d","excerpt":"As opposed to pessimistic locking which translates into FOR UPDATE from Hibernate, Optimistic locking simply passes on a \"WHERE VERSION = 4\" in the updateâ€¦","html":"<p>As opposed to pessimistic locking which translates into FOR UPDATE from Hibernate, Optimistic locking simply passes on a \"WHERE VERSION = 4\" in the update statement. This is small but significant change in the application code and end user flow. Since pessimistic locking LOCKS that row entirely, if we go back to the kiosk example they would reach a screen that would just HANG and see a spinner until the person editing that row finishes what they're doing (resulting in a TICKET SOLD notification).</p>\n<p>Remember also that the first example is a \"LOST UPDATE\" as default behavior. If we don't catch and have business logic, at contention or concurrent behavior, SQL would see nothing wrong with the ticket inventory being decremented past 0. You can't even have busines logic to catch this either! Let's say you have something that says \"If inventory &#x3C; 1, fail!\" in your java spring boot code. because that in flight transaction is reading stale data, it would think the inventory is still 1!</p>\n<p>You'd have to use some sort of UNIQUE CONSTRAINT as an integrity constraint, like this</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ALTER TABLE tickets ADD CONSTRAINT quantity_not_negative CHECK (quantity >= 0);</code></pre></div>\n<p>Anyways. Let's move onto optimistic. If the default just goes through (or fails with that constraint above but the intent is a little wonky vs just having a pessmistic lock), and the pessmistic locks the screen, optmistic will simply pass along that WHERE VERSION is as we said. This DOESN'T result in a SQL db failure as \"0 rows updated\" seem fine, but at the application spring boot level an OptimisticLockingFailureException happens!</p>\n<p>Unlike the lock annotation, we add a @version annotation to our entity:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">@Entity\npublic class Ticket {\n    @Id\n    private Long id;\n    private Integer quantity;\n\n    @Version  // &lt;--- The Magic Ingredient\n    private Long version;\n}</code></pre></div>\n<p>and then in our service</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">@Transactional\npublic void purchaseTicket(Long ticketId) {\n    // 1. SELECT: Alice and Bob both get the ticket with version = 1\n    Ticket ticket = repo.findById(ticketId).get();\n\n    if (ticket.getQuantity() > 0) {\n        paymentService.charge(user, price); // The \"Human Window\"\n        \n        ticket.setQuantity(ticket.getQuantity() - 1);\n        \n        // 2. SAVE: Alice succeeds.\n        // When Bob tries, Hibernate runs: \n        // UPDATE ticket SET quantity=0, version=2 WHERE id=1 AND version=1;\n        // Bob's call fails here with OptimisticLockingFailureException.\n        repo.save(ticket);\n    }\n}</code></pre></div>\n<p>I tried using a kiosk analogy for this with Gemini, it summed it up as this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">How it compares to your Kiosk thoughts:\nYou mentioned: \"instead of hanging or saying it's out of date, we could display the same error again right, that the version is out of date if there's any concurrency?\"\n\nExactly. The user experience is:\n\nPessimistic: Bob waits for Alice to finish (Slow).\n\nOptimistic: Bob does all his work, but when he hits \"Confirm,\" he gets an immediate \"Sorry, someone beat you to it\" message (Fast, but potentially annoying for Bob).\n\nWhen to use which?\nPessimistic: High contention (e.g., a \"Flash Sale\"). If you know 100 people are fighting for 1 item, don't let 99 people fill out credit card forms just to fail at the end. Make them wait.\n\nOptimistic: Low contention (e.g., editing a User Profile). It's rare that two people edit the same profile at the exact same second, so don't bother with the overhead of locks.</code></pre></div>","frontmatter":{"title":"Database Fundamentals - Optimistic locking","date":"February 02, 2026","description":"Reflections on optimistic locking specifically implemented in Spring boot with Postgres"}},"previous":{"fields":{"slug":"/db-pt2/"},"frontmatter":{"title":"Database Fundamentals - Pessimistic locking"}},"next":{"fields":{"slug":"/webdev-pagination/"},"frontmatter":{"title":"Pagination"}}},"pageContext":{"id":"9a71fe5f-079b-54dd-af55-8b95844ba53d","previousPostId":"95727ab1-dae1-5017-aa89-ff3ff4ff49a5","nextPostId":"079d73c2-4f00-5708-aa1f-8eb3252a5411"}},"staticQueryHashes":["2841359383","3257411868"],"slicesMap":{}}