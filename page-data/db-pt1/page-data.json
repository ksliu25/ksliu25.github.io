{"componentChunkName":"component---src-templates-blog-post-js","path":"/db-pt1/","result":{"data":{"site":{"siteMetadata":{"title":"Ken's Feynman Dump"}},"markdownRemark":{"id":"2138fea4-911d-53b2-bd16-1355932b9aac","excerpt":"Stuff taken directly from my conversations with chatgpt/Gemini because I'm too dumb to understand basic computer science Postgres MVCC lets everyone read and…","html":"<h2>Stuff taken directly from my conversations with chatgpt/Gemini because I'm too dumb to understand basic computer science</h2>\n<p>Postgres MVCC lets everyone read and write at the same time by keeping multiple versions of data. It doesn’t stop conflicts — it just avoids blocking.\nOptimistic and pessimistic locking are how the application decides what to do when conflicts matter.\nMVCC is optimistic in attitude (assume things won’t collide), but it doesn’t enforce correctness. Locking is where correctness gets enforced</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Imagine a giant concert stadium.\n\nThe Snapshot (MVCC): Person A and Person B both walk up to their own separate electronic kiosks at the exact same time. When they touch the screen, the kiosk pulls a \"snapshot\" of the seating map. Both screens show one seat left (Seat 1A).\n\nThe Interpretation: * Person A thinks: \"Awesome, Seat 1A is free. I'll take it.\"\n\nPerson B thinks: \"Awesome, Seat 1A is free. I'll take it.\"\n\nThe Lost Update (The Conflict):\n\nPerson A hits \"Confirm.\" The database (Postgres) sees the seat is currently empty and marks it as \"Sold to A.\"\n\nPerson B hits \"Confirm\" a millisecond later and the transaction goes through</code></pre></div>\n<p>Make note that the concurrency in this case, although it says millisecond later, can specifically mean \"execution windows\".</p>\n<p>Take a look at a default bread and butter spring boot implementaiton</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">@Transactional\npublic void purchaseTicket(Long ticketId) {\n    // 1. SELECT: Get current inventory\n    Ticket ticket = repo.findById(ticketId); // Inventory = 1\n    \n    if (ticket.getQuantity() > 0) {\n        \n        // 2. THE HUMAN WINDOW: 3rd party credit card call (takes 2 seconds)\n        paymentService.charge(user, price); \n        \n        // 3. UPDATE: Decrement and save\n        ticket.setQuantity(ticket.getQuantity() - 1);\n        repo.save(ticket); \n    }\n}</code></pre></div>\n<p>If you have two users, Alice and Bob, the sequence looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">T1: Alice hits the endpoint. Her transaction starts. She executes SELECT and sees Quantity = 1.\n\nT2: Bob hits the endpoint. His transaction starts. He executes SELECT and also sees Quantity = 1 because Alice hasn't changed anything yet.\n\nT3: Alice is waiting for the credit card API (the 2-second \"Human Window\").\n\nT4: Bob is also waiting for the credit card API.\n\nT5: Alice’s payment clears. Her code executes the UPDATE to set Quantity = 0. Her transaction commits.\n\nT6: Bob’s payment clears. His code executes the UPDATE to set Quantity = 0. His transaction commits.\n\nThe Result: Two people paid, but the inventory only went down by 1.</code></pre></div>\n<p>I had a hard time forming a coherent mental model on this as I needed more and more concrete examples to understand what \"concurrency\" really meant in the context of \"two database transactions come in at the same time!\" (Which is a somewhat separate but related topic...)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Why this is a \"Human Level\" problem\nYou mentioned this is for human-level timing. You're right because:\n\nDB level: Transactions usually take microseconds.\n\nApp level: Between the SELECT and the UPDATE, you might have business logic, loops, or IO calls.\n\nIf you use a \"Long Conversation\" (like a user opening an 'Edit' screen, going to get coffee, and then hitting 'Save'), the window isn't 2 seconds; it's 20 minutes. Plain MVCC is completely helpless here because the database cannot hold a lock for 20 minutes while a user is away from their keyboard.</code></pre></div>\n<p>Talking more with Gemini, I wanted to know if these things occurred near the outset of web development because it just didn't make much sense to me that a user would enter an \"edit\" mode and have a long running db connection open for that long... but these ideas are very educational to explore and glean the intuition going from the very start to finish of modern web development.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Phase 1: The \"Wild West\" (Plain MVCC)In the early days of simple web apps, we relied on the database's default behavior.\nThe Flow: Alice reads data > Alice sees it on her screen > Alice clicks \"Save\" 10 minutes later > The app sends an UPDATE.\n\nThe Problem: If Bob edited the same record while Alice was at lunch, Alice’s \"Save\" would blindly overwrite Bob’s changes. This is the Lost Update in a stateless environment.\n\nIntuition: The database is just a filing cabinet. It doesn't know Alice's \"Save\" is based on 10-minute-old information.</code></pre></div>","frontmatter":{"title":"Database Fundamentals - Default MVCC behavior in PostgreSQL","date":"January 23, 2026","description":"Exploring the motivations for optimistic and pessimistic locking specifically implemented in Spring boot with Postgres"}},"previous":null,"next":{"fields":{"slug":"/db-pt2/"},"frontmatter":{"title":"Database Fundamentals - Optimistic and Pessimistic locking"}}},"pageContext":{"id":"2138fea4-911d-53b2-bd16-1355932b9aac","previousPostId":null,"nextPostId":"95727ab1-dae1-5017-aa89-ff3ff4ff49a5"}},"staticQueryHashes":["2841359383","3257411868"],"slicesMap":{}}