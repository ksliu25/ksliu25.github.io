<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Gatsby Starter Blog RSS Feed]]></title><description><![CDATA[A starter blog demonstrating what Gatsby can do.]]></description><link>https://gatsbystarterblogsource.gatsbyjs.io</link><generator>GatsbyJS</generator><lastBuildDate>Tue, 03 Feb 2026 15:30:51 GMT</lastBuildDate><item><title><![CDATA[Database Fundamentals - Optimistic locking]]></title><description><![CDATA[As opposed to pessimistic locking which translates into FOR UPDATE from Hibernate, Optimistic locking simply passes on a "WHERE VERSION =…]]></description><link>https://gatsbystarterblogsource.gatsbyjs.io/db-pt3/</link><guid isPermaLink="false">https://gatsbystarterblogsource.gatsbyjs.io/db-pt3/</guid><pubDate>Tue, 03 Feb 2026 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;As opposed to pessimistic locking which translates into FOR UPDATE from Hibernate, Optimistic locking simply passes on a &quot;WHERE VERSION = 4&quot; in the update statement. This is small but significant change in the application code and end user flow. Since pessimistic locking LOCKS that row entirely, if we go back to the kiosk example they would reach a screen that would just HANG and see a spinner until the person editing that row finishes what they&apos;re doing (resulting in a TICKET SOLD notification).&lt;/p&gt;
&lt;p&gt;Remember also that the first example is a &quot;LOST UPDATE&quot; as default behavior. If we don&apos;t catch and have business logic, at contention or concurrent behavior, SQL would see nothing wrong with the ticket inventory being decremented past 0. You can&apos;t even have busines logic to catch this either! Let&apos;s say you have something that says &quot;If inventory &amp;#x3C; 1, fail!&quot; in your java spring boot code. because that in flight transaction is reading stale data, it would think the inventory is still 1!&lt;/p&gt;
&lt;p&gt;You&apos;d have to use some sort of UNIQUE CONSTRAINT as an integrity constraint, like this&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;ALTER TABLE tickets ADD CONSTRAINT quantity_not_negative CHECK (quantity &gt;= 0);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Anyways. Let&apos;s move onto optimistic. If the default just goes through (or fails with that constraint above but the intent is a little wonky vs just having a pessmistic lock), and the pessmistic locks the screen, optmistic will simply pass along that WHERE VERSION is as we said. This DOESN&apos;T result in a SQL db failure as &quot;0 rows updated&quot; seem fine, but at the application spring boot level an OptimisticLockingFailureException happens!&lt;/p&gt;
&lt;p&gt;Unlike the lock annotation, we add a @version annotation to our entity:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;@Entity
public class Ticket {
    @Id
    private Long id;
    private Integer quantity;

    @Version  // &amp;lt;--- The Magic Ingredient
    private Long version;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and then in our service&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;@Transactional
public void purchaseTicket(Long ticketId) {
    // 1. SELECT: Alice and Bob both get the ticket with version = 1
    Ticket ticket = repo.findById(ticketId).get();

    if (ticket.getQuantity() &gt; 0) {
        paymentService.charge(user, price); // The &quot;Human Window&quot;
        
        ticket.setQuantity(ticket.getQuantity() - 1);
        
        // 2. SAVE: Alice succeeds.
        // When Bob tries, Hibernate runs: 
        // UPDATE ticket SET quantity=0, version=2 WHERE id=1 AND version=1;
        // Bob&apos;s call fails here with OptimisticLockingFailureException.
        repo.save(ticket);
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I tried using a kiosk analogy for this with Gemini, it summed it up as this:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;How it compares to your Kiosk thoughts:
You mentioned: &quot;instead of hanging or saying it&apos;s out of date, we could display the same error again right, that the version is out of date if there&apos;s any concurrency?&quot;

Exactly. The user experience is:

Pessimistic: Bob waits for Alice to finish (Slow).

Optimistic: Bob does all his work, but when he hits &quot;Confirm,&quot; he gets an immediate &quot;Sorry, someone beat you to it&quot; message (Fast, but potentially annoying for Bob).

When to use which?
Pessimistic: High contention (e.g., a &quot;Flash Sale&quot;). If you know 100 people are fighting for 1 item, don&apos;t let 99 people fill out credit card forms just to fail at the end. Make them wait.

Optimistic: Low contention (e.g., editing a User Profile). It&apos;s rare that two people edit the same profile at the exact same second, so don&apos;t bother with the overhead of locks.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[Pagination]]></title><description><![CDATA[Stuff taken directly from my conversations with chatgpt/Gemini because I'm too dumb to understand basic computer science]]></description><link>https://gatsbystarterblogsource.gatsbyjs.io/webdev-pagination/</link><guid isPermaLink="false">https://gatsbystarterblogsource.gatsbyjs.io/webdev-pagination/</guid><pubDate>Tue, 03 Feb 2026 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Stuff taken directly from my conversations with chatgpt/Gemini because I&apos;m too dumb to understand basic computer science&lt;/h2&gt;</content:encoded></item><item><title><![CDATA[Database Fundamentals - Default MVCC behavior in PostgreSQL]]></title><description><![CDATA[Stuff taken directly from my conversations with chatgpt/Gemini because I'm too dumb to understand basic computer science Postgres MVCC lets…]]></description><link>https://gatsbystarterblogsource.gatsbyjs.io/db-pt1/</link><guid isPermaLink="false">https://gatsbystarterblogsource.gatsbyjs.io/db-pt1/</guid><pubDate>Thu, 29 Jan 2026 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Stuff taken directly from my conversations with chatgpt/Gemini because I&apos;m too dumb to understand basic computer science&lt;/h2&gt;
&lt;p&gt;Postgres MVCC lets everyone read and write at the same time by keeping multiple versions of data. It doesn’t stop conflicts — it just avoids blocking.
Optimistic and pessimistic locking are how the application decides what to do when conflicts matter.
MVCC is optimistic in attitude (assume things won’t collide), but it doesn’t enforce correctness. Locking is where correctness gets enforced&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Imagine a giant concert stadium.

The Snapshot (MVCC): Person A and Person B both walk up to their own separate electronic kiosks at the exact same time. When they touch the screen, the kiosk pulls a &quot;snapshot&quot; of the seating map. Both screens show one seat left (Seat 1A).

The Interpretation: * Person A thinks: &quot;Awesome, Seat 1A is free. I&apos;ll take it.&quot;

Person B thinks: &quot;Awesome, Seat 1A is free. I&apos;ll take it.&quot;

The Lost Update (The Conflict):

Person A hits &quot;Confirm.&quot; The database (Postgres) sees the seat is currently empty and marks it as &quot;Sold to A.&quot;

Person B hits &quot;Confirm&quot; a millisecond later and the transaction goes through&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Make note that the concurrency in this case, although it says millisecond later, can specifically mean &quot;execution windows&quot;.&lt;/p&gt;
&lt;p&gt;Take a look at a default bread and butter spring boot implementaiton&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;@Transactional
public void purchaseTicket(Long ticketId) {
    // 1. SELECT: Get current inventory
    Ticket ticket = repo.findById(ticketId); // Inventory = 1
    
    if (ticket.getQuantity() &gt; 0) {
        
        // 2. THE HUMAN WINDOW: 3rd party credit card call (takes 2 seconds)
        paymentService.charge(user, price); 
        
        // 3. UPDATE: Decrement and save
        ticket.setQuantity(ticket.getQuantity() - 1);
        repo.save(ticket); 
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you have two users, Alice and Bob, the sequence looks like this:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;T1: Alice hits the endpoint. Her transaction starts. She executes SELECT and sees Quantity = 1.

T2: Bob hits the endpoint. His transaction starts. He executes SELECT and also sees Quantity = 1 because Alice hasn&apos;t changed anything yet.

T3: Alice is waiting for the credit card API (the 2-second &quot;Human Window&quot;).

T4: Bob is also waiting for the credit card API.

T5: Alice’s payment clears. Her code executes the UPDATE to set Quantity = 0. Her transaction commits.

T6: Bob’s payment clears. His code executes the UPDATE to set Quantity = 0. His transaction commits.

The Result: Two people paid, but the inventory only went down by 1.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I had a hard time forming a coherent mental model on this as I needed more and more concrete examples to understand what &quot;concurrency&quot; really meant in the context of &quot;two database transactions come in at the same time!&quot; (Which is a somewhat separate but related topic...)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Why this is a &quot;Human Level&quot; problem
You mentioned this is for human-level timing. You&apos;re right because:

DB level: Transactions usually take microseconds.

App level: Between the SELECT and the UPDATE, you might have business logic, loops, or IO calls.

If you use a &quot;Long Conversation&quot; (like a user opening an &apos;Edit&apos; screen, going to get coffee, and then hitting &apos;Save&apos;), the window isn&apos;t 2 seconds; it&apos;s 20 minutes. Plain MVCC is completely helpless here because the database cannot hold a lock for 20 minutes while a user is away from their keyboard.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Talking more with Gemini, I wanted to know if these things occurred near the outset of web development because it just didn&apos;t make much sense to me that a user would enter an &quot;edit&quot; mode and have a long running db connection open for that long... but these ideas are very educational to explore and glean the intuition going from the very start to finish of modern web development.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Phase 1: The &quot;Wild West&quot; (Plain MVCC)In the early days of simple web apps, we relied on the database&apos;s default behavior.
The Flow: Alice reads data &gt; Alice sees it on her screen &gt; Alice clicks &quot;Save&quot; 10 minutes later &gt; The app sends an UPDATE.

The Problem: If Bob edited the same record while Alice was at lunch, Alice’s &quot;Save&quot; would blindly overwrite Bob’s changes. This is the Lost Update in a stateless environment.

Intuition: The database is just a filing cabinet. It doesn&apos;t know Alice&apos;s &quot;Save&quot; is based on 10-minute-old information.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[Database Fundamentals - Pessimistic locking]]></title><description><![CDATA[Stuff taken directly from my conversations with chatgpt/Gemini because I'm too dumb to understand basic computer science So we talked about…]]></description><link>https://gatsbystarterblogsource.gatsbyjs.io/db-pt2/</link><guid isPermaLink="false">https://gatsbystarterblogsource.gatsbyjs.io/db-pt2/</guid><pubDate>Thu, 29 Jan 2026 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Stuff taken directly from my conversations with chatgpt/Gemini because I&apos;m too dumb to understand basic computer science&lt;/h2&gt;
&lt;p&gt;So we talked about the default behavior of multi version concurrency control in Postgres which is &quot;optimistic&quot; in nature. It&apos;s not thinking that there&apos;s going to be any contention. There are two different ways to handle this in application code (we&apos;re not going to cover the isolation levels at the db level because frankly I haven&apos;t explored them quite yet).&lt;/p&gt;
&lt;p&gt;As we exemplified before, the default behavior has an implicit lock at the update and allows for &quot;clean&quot; reads making sure that there is no blocking when a resource is being read.&lt;/p&gt;
&lt;p&gt;But for financial systems or systems that are of paramount importance -- including what we mentioned before with ticketing systems -- you CAN&apos;T just oversell tickets or lose a deposit, right?&lt;/p&gt;
&lt;p&gt;This is where &quot;Pessimistic&quot; locking comes into play. And once again i want to reiterate that mvcc is simply about visibility and not blocking, but now we&apos;re introducing specific locking mechanisms that we&apos;ll see in the application code.&lt;/p&gt;
&lt;p&gt;Let&apos;s imagine the same scenario with the kiosk as mentioned before in part 1, but this time with pessmistic locking:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Imagine a giant concert stadium.

Pessimistic Locking: Person A and Person B both walk up to their own separate electronic kiosks at the exact same time. When they touch the screen, the kiosk pulls a &quot;snapshot&quot; of the seating map. Both screens show one seat left (Seat 1A).

The Interpretation: * Person A thinks: &quot;Awesome, Seat 1A is free. I&apos;ll take it.&quot;

Person B thinks: &quot;Awesome, Seat 1A is free. I&apos;ll take it.&quot;

Person A clicks on the seat, this locks the seat for updating. Underneath the hood, in Hibernate, it translates to a FOR UPDATE select statement.

A millisecond later Person B goes to click on the seat, but the kiosk just FREEZES and remains frozen until person A is finished with what they&apos;re doing. 

Eventually, person B gets a notice saying &quot;Sorry, this seat has been taken&quot;.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is only an analogy as in REAL life at ticket master or this kiosk other mechanisms would be at play -- most likely redis caching with NX, soft locking and websockets, but that will be explored later.&lt;/p&gt;
&lt;p&gt;Here&apos;s another alternative analogy:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;How to explain it simply:
If you’re explaining this to someone else, use the &quot;Phone Line&quot; analogy:

MVCC: It’s like a recorded message. Everyone can call and hear the status of the seat at the same time. The recording might be old, but the line is never busy.

Pessimistic Locking: It’s like calling a human operator. If Alice is talking to the operator about Seat 1A, when Bob calls, he gets a busy signal (or stays on hold). He can&apos;t even get information about the seat until Alice hangs up.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let&apos;s look at this implemented in a simple Java Spring Boot snippet. At the repository level:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;public interface TicketRepository extends JpaRepository&amp;lt;Ticket, Long&gt; {

    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query(&quot;SELECT t FROM Ticket t WHERE t.id = :id&quot;)
    Optional&amp;lt;Ticket&gt; findByIdWithLock(@Param(&quot;id&quot;) Long id);
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And at the service level as before:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;@Service
public class TicketService {

    @Autowired
    private TicketRepository repo;

    @Transactional
    public void purchaseTicket(Long ticketId) {
        // 1. SELECT ... FOR UPDATE
        // If another transaction has this lock, this thread HANGS here until the lock is released.
        Ticket ticket = repo.findByIdWithLock(ticketId)
            .orElseThrow(() -&gt; new RuntimeException(&quot;Ticket not found&quot;));

        if (ticket.getQuantity() &gt; 0) {
            
            // 2. THE HUMAN WINDOW: 3rd party credit card call (2 seconds)
            // Alice is safe here because she holds the DB lock. 
            // Bob is stuck at step 1 on his kiosk/thread.
            paymentService.charge(user, price); 
            
            // 3. UPDATE: Decrement and save
            ticket.setQuantity(ticket.getQuantity() - 1);
            repo.save(ticket); 
        } // 4. TRANSACTION COMMITS: Lock is released here.
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Some notes from Gemini.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Important Considerations for Pessimistic Locking
Timeouts: You generally don&apos;t want Bob to wait forever. You can set a hint to tell the DB to give up after a few seconds: @QueryHints({@QueryHint(name = &quot;javax.persistence.lock.timeout&quot;, value = &quot;3000&quot;)})

Database Connections: Remember that while Bob is waiting, he is still holding onto a connection from your HikariCP connection pool. If you have 100 &quot;Bobs&quot; all waiting for one &quot;Alice,&quot; you can quickly exhaust your pool and crash the whole app.

Deadlocks: If Alice locks Row 1 and wants Row 2, while Bob locks Row 2 and wants Row 1, they will wait for each other forever. Postgres will eventually detect this and kill one of the transactions.

This is the most &quot;secure&quot; way to handle high-contention data like money or inventory, provided the &quot;Human Window&quot; (the payment call) is relatively short.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the real world since this causes so much hang, systems at scale push this waiting at a higher level. For ticketing systems, they relieve backpressure with Queue systems to let people into a presale event, and even at the sale event soft locks happen at a Redis cache level maybe partitioned by event_id and seat_id to ensure even distribution across the clusters to handle traffic.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/6dca5af9f93b3a687e19783878ae81f2/321ea/image.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 33.54430379746836%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAA7DAAAOwwHHb6hkAAABHklEQVR42j1RB3LDMAzz/3/Y5tpYjre89xRKMFF9x4MF0hBAB1EUwRgDYpplivtxgI9zTutWxLuEvz+8f/yZTNB0A67L4bqB8wKmeUVeVKjqDsfpPtyGoqwxLzu2/ULTDrC2RWFr4Sus26mz+3EjeIaxuEqQpoWS/TDjFWfitlDRmtX0CM0LrVzOj2zVohSxLLdaNOB7wTit6PoJRArSxTAuKkzkEPulbf4d0jHn/Qzfl/V4C34/fsRRqg3GppskzSVWr+54CQUZeZwWFaR7OmT0thu1tv2U9TgEv0/5KRKZTe6LmGal4IhRnJCjEzr0LhiTsSnkRYncf8CDlWEvWMqyvx6hLLzFJBHJcSZOcl0+HRoT6355EXtMwOJK/gDGKxieaRdIzwAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;alt text&quot;
        title=&quot;&quot;
        src=&quot;/static/6dca5af9f93b3a687e19783878ae81f2/f058b/image.png&quot;
        srcset=&quot;/static/6dca5af9f93b3a687e19783878ae81f2/c26ae/image.png 158w,
/static/6dca5af9f93b3a687e19783878ae81f2/6bdcf/image.png 315w,
/static/6dca5af9f93b3a687e19783878ae81f2/f058b/image.png 630w,
/static/6dca5af9f93b3a687e19783878ae81f2/321ea/image.png 786w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;</content:encoded></item></channel></rss>